#!/bin/bash
#
# https://github.com/Aniverse/inexistence
# Author: Aniverse
#
# --------------------------------------------------------------------------------
# If you would like to change the output path,
# sets CustomedOutput=1，then write your output path to OUTPUT
CustomedOutput=0
OUTPUT="/replace/here/with/your/output/path"
# --------------------------------------------------------------------------------
pics=10
# --------------------------------------------------------------------------------
script_update=2020.03.29
script_version=r21048
# --------------------------------------------------------------------------------

# Cleanup when cancel
cancel() { echo -e "${normal}" ; rm -f "${outputpath}/${file_title_clean}*" ; exit ; }
trap cancel SIGINT

# Colors
black=$(tput setaf 0); red=$(tput setaf 1); green=$(tput setaf 2); yellow=$(tput setaf 3); blue=$(tput setaf 4); magenta=$(tput setaf 5); cyan=$(tput setaf 6); white=$(tput setaf 7)
bold=$(tput bold); normal=$(tput sgr0); underline=$(tput smul); reset_underline=$(tput rmul); jiacu=${normal}${bold}

mediapath="$1" ; fenbianlv="$2"
Source=undefined

[[ ! $(command -v awk) ]] && echo -e "\n${red}${bold}ERROR${jiacu} awk not found, please install it${normal}" && exit 1
[[ ! $(command -v ffmpeg) ]] && echo -e "\n${red}${bold}ERROR${jiacu} ffmpeg not found, please install it or set it to your \$PATH\n${normal}" && exit 1
[[ ! $(command -v mediainfo) ]] && echo -e "\n${red}${bold}ERROR${jiacu} mediainfo not found, please install it or set it to your \$PATH\n${normal}" && exit 1
[[ $EUID != 0 ]] && [[ $CustomedOutput == 0 ]] && echo -e "\n${red}${bold}ERROR${jiacu} Please edit this script to set output path first\n${normal}" && exit 1

[[ -z "$mediapath" ]] && echo -e "\n${red}${bold}WARNING${jiacu} You must input the path to your file with double quotes\n${normal}" && exit 1
[[ ! $( ls "$mediapath" 2>/dev/null ) ]] && echo -e "\n${red}${bold}WARNING${jiacu} This file or dictionary doesn't exist, or it's empty\n${normal}" && exit 1

omediapath="$mediapath"
FileLoc="$(dirname "$omediapath")"
#FileLoc_sed="$(echo $FileLoc | sed -e 's/\//\\\//g')"

[[ -d "$mediapath" ]] && {
mediapath=$( find "$mediapath" -type f -print0 | xargs -0 ls -1S 2>&1 | head -1 )

# DVD Name/VIDEO_TS/VTS_01_1.VOB
dirname "$mediapath" | grep VIDEO_TS -q && Source=DVD && 
ifo="$( find "$omediapath" -type f -name "*.[Ii][Ff][Oo]" -print0 | xargs -0 ls -S 2>&1 | head -1 )" &&
disk_path="$(dirname "$(dirname "$mediapath")")" && disk_title="$(basename "$disk_path")"

# Blu-ray Name/BDMV/STREAM/00002.m2ts
dirname "$mediapath" | grep STREAM   -q && Source=Blu-ray &&
disk_path="$( dirname "$( dirname "$(dirname "$mediapath")")")" && disk_title="$(basename "$disk_path")"

[[ ! -z $disk_title ]] && {
disk_title_clean="$(echo "$disk_title"       | tr '[:space:]' '.')"
disk_title_clean="$(echo "$disk_title_clean" | sed s'/[.]$//')"
disk_title_clean="$(echo "$disk_title_clean" | tr -d '(')"
disk_title_clean="$(echo "$disk_title_clean" | tr -d ')')" ; }

if [[ $Source == DVD ]]; then
#   echo -e "\nThis is a DVD, ${underline}${mediapath}${reset_underline} would be used for taking screenshots and mediainfo,${normal}"
#   echo -e "and the mediainfo of ${underline}${ifo}${reset_underline} would be added to the report too${normal}"
    echo -e "\n${bold}This is a DVD, we will take screenshots for a main VOB file,\nand mediainfo reports of a main VOB file and the correct IFO file${normal}"
else
#   echo -e "\n${red}${bold}ATTENTION${normal} You have input a dictionary, so we find the biggest file for taking screenshots,\nwhich is ${underline}${mediapath}${reset_underline}${normal}"
    echo -e "\n${bold}You have input a dictionary, we find the biggest file for taking screenshots,\nwhich is ${blue}${mediapath}${normal}"
fi ; }


#######################################################################################################################
#######################################################################################################################
#######################################################################################################################
#######################################################################################################################
#######################################################################################################################


echo -e "\n${bold}Calculating resolution ...${normal}"

VideoResolution=$( ffmpeg -i "$mediapath" 2>&1 | grep -E "Stream.*Video" | grep -Eo "[0-9]{2,5}x[0-9]{2,5}" | head -1 )
VideoWidth=$( echo $VideoResolution | sed "s/x[0-9]\{2,\}//" | head -1 )  # X
VideoHeight=$( echo $VideoResolution | sed "s/[0-9]\{2,\}x//" | head -1 ) # Y
PAR=$( mediainfo -f "$mediapath" 2>&1 | grep -i "Pixel aspect ratio" | grep -oE "[0-9.]+" | head -1 )
DAR2=$( mediainfo -f "$mediapath" 2>&1 | grep -i "Display aspect ratio" | grep -oE "[0-9.]+" | head -1 )
# mediainfo 的 PAR 和 DAR 都是直接是小数

# 2019.05.24 前阵子还是有人和我反应算错了，发现还真的是算错了
# PTP 那个自动算的系统是用 mediainfo 算的，那我最后也还是要用 mediainfo
# 之前没用主要就是因为浮点数计算的问题，现在发现这个问题避不开， bc 和 awk 至少要一个，或者就用 per、python
# 那我还不如用广泛预装了的 awk ……
PARX=$(awk "BEGIN{print $VideoWidth*$PAR}" | awk '{print int($0)}')
[ $(($PARX%2)) != 0 ] && PARX=$( expr $PARX + 1 )
PARY=$(awk "BEGIN{print $VideoHeight/$PAR}" | awk '{print int($0)}')
[ $(($PARY%2)) != 0 ] && PARY=$( expr $PARY + 1 )
# 小于等于 1，用 Y 除以 PAR（对于 PAR 等于 1 的来说除了 1 也不变所以无所谓）
if [[ $(awk "BEGIN{print $PAR*1000}") -le 1000 ]] ; then
    resize=Y
    TrueRes2="${VideoWidth}x${PARY}"
else
    resize=X
    TrueRes2="${PARX}x${VideoHeight}"
fi



#######################################################################################################################
#######################################################################################################################
#######################################################################################################################
#######################################################################################################################
#######################################################################################################################


# TEST MODE
[[ $fenbianlv == -t ]] && {

# ${cyan}${bold}FileName               ${yellow}$mediapath
echo -e "
${cyan}${bold}jietu version          ${yellow}$script_version ($script_update)
${cyan}${bold}Source Type            ${yellow}$Source
${cyan}${bold}File Location          ${yellow}$FileLoc
${cyan}${bold}File Name              ${yellow}$omediapath"
[[ $Source == DVD     ]] && echo -e \
"${cyan}${bold}DVD IFO File           ${yellow}$ifo
${cyan}${bold}DVD Title              ${yellow}$disk_title_clean"
[[ $Source == Blu-ray ]] && echo -e \
"${cyan}${bold}Blu-ray Title          ${yellow}$disk_title_clean"

#  ${cyan}${bold}Sample  Aspect Ratio   ${yellow}$SAR\t${normal}${bold}(ffmpeg)
#  ${cyan}${bold}Display Aspect Ratio   ${yellow}$DAR\t${normal}${bold}(ffmpeg)

echo -e "
${cyan}${bold}Pixel   Aspect Ratio   ${yellow}$PAR\t${normal}${bold}(mediainfo)
${cyan}${bold}Display Aspect Ratio   ${yellow}$DAR2\t${normal}${bold}(mediainfo)
${cyan}${bold}Video Resolution       ${yellow}$VideoResolution
${cyan}${bold}PAR   Resolution       ${yellow}$TrueRes2
${green}
mediapath=\"$mediapath\"
ffmpeg -i \"\$mediapath\"
mediainfo -f \"\$mediapath\"
${normal}"
[[ ! $Source == undefined ]] && ls -hAlvZ --color "$(dirname "$mediapath")"
echo -e "\n\n"
ffmpeg -i "$mediapath"
echo
exit 0 ; }


#######################################################################################################################
#######################################################################################################################
#######################################################################################################################
#######################################################################################################################
#######################################################################################################################


if [[ -z "$fenbianlv" ]]; then
########################################################################################################################
fenbianlv="$TrueRes2"
echo -e "${bold}
${cyan}Display Aspect Ratio  ${yellow}$DAR2
${cyan}Pixel   Aspect Ratio  ${yellow}$PAR
${cyan}Video Resolution      ${yellow}$VideoResolution  --->  $fenbianlv${normal}"
########################################################################################################################
fi

[[ $Source == DVD ]] && {
echo -e "${bold}${cyan}DVD IFO File  ${yellow}$ifo
${cyan}DVD VOB File  ${yellow}$mediapath${normal}" ; }





file_title=$(basename "$mediapath")
file_title_clean="$(echo "$file_title" | tr '[:space:]' '.')"
file_title_clean="$(echo "$file_title_clean" | sed s'/[.]$//')"
file_title_clean="$(echo "$file_title_clean" | tr -d '(')"
file_title_clean="$(echo "$file_title_clean" | tr -d ')')"
[[ ! -z $disk_title_clean ]] &&
file_title_clean="$(echo "${disk_title_clean}.${file_title_clean}")"

# Calculating timestampsetting
duration1=$(ffmpeg -i "$mediapath" 2>&1 | egrep '(Duration:)' | cut -d ' ' -f4 | cut -c1-8)
duration2=`date -u -d "1970-01-01 $duration1" +%s`
if [[ "${duration2}" -ge 3600 ]]; then
    timestampsetting=331
elif [[ "${duration2}" -ge 1500 && "${duration2}" -lt 3600 ]]; then
    timestampsetting=121
elif [[ "${duration2}" -ge 600 && "${duration2}" -lt 1500 ]]; then
    timestampsetting=71
elif [[ "${duration2}" -lt 600 ]]; then
    timestampsetting=21
fi

[[   $CustomedOutput == 0 ]] && mkdir -p "/log/screenshots" && outputpath="/log/screenshots"
[[ ! $CustomedOutput == 0 ]] && mkdir -p "$OUTPUT" && outputpath="$OUTPUT"

echo

# Screenshots
for c in $(seq -w 1 $pics) ; do

    i=`expr $i + $timestampsetting` ; timestamp=`date -u -d @$i +%H:%M:%S`
    echo -n "Writing ${blue}${file_title_clean}.scr${c}.png${normal} from timestamp ${blue}${timestamp}${normal} ...  "
  # ffmpeg -y -ss $timestamp -i "$mediapath" -vframes 1 -s $fenbianlv "${outputpath}/${file_title_clean}.scr${c}.png" > /dev/null 2>&1
    ffmpeg -y -ss $timestamp -i "$mediapath" -ss 00:00:01 -frames:v 1 -s $fenbianlv "${outputpath}/${file_title_clean}.scr${c}.png" > /dev/null 2>&1
    [[ -f "${outputpath}/${file_title_clean}.scr${c}.png" ]] && success_src=y || success_src=n
    [[ $success_src == y ]] && echo -e "${green}DONE${normal}" || echo -e "${green}ERROR${normal}"

    [[ $(command -v nconvert) ]] && {
    echo -n "Compressing ${blue}${file_title_clean}.scr${c}.png${normal} ${normal} ...  "
    nconvert -out png -clevel 6 -o "${outputpath}/${file_title_clean}.scr${c}_1.png" "${outputpath}/${file_title_clean}.scr${c}.png" > /dev/null 2>&1
    [[ $? -eq 0 ]] && success_convert=y || success_convert=n
    mv -f "${outputpath}/${file_title_clean}.scr${c}_1.png" "${outputpath}/${file_title_clean}.scr${c}.png" > /dev/null 2>&1
    [[ $success_convert == y ]] && echo -e "${green}DONE${normal}" || echo -e "${green}ERROR${normal}" ; }

done

###################################################### mediainfo #######################################################

echo -ne "\nWriting ${blue}${file_title_clean}.mediainfo.txt${normal} ...  "
mediainfo "$mediapath" > "${outputpath}/${file_title_clean}.mediainfo.txt"
[[ $? -eq 0 ]] && success_info=y || success_info=n
sed -i "s|${FileLoc}/||" "${outputpath}/${file_title_clean}.mediainfo.txt"
[[ $success_info == y ]] && echo -e "${green}DONE${normal}" || echo -e "${green}ERROR${normal}"

[[ -n "$ifo" ]] && {
echo -ne "Adding IFO mediainfo to ${blue}${file_title_clean}.mediainfo.txt${normal} ...  "
echo -e "\n\n" >> "${outputpath}/${file_title_clean}.mediainfo.txt"
mediainfo "$ifo" >> "${outputpath}/${file_title_clean}.mediainfo.txt"
[[ $? -eq 0 ]] && success_ifo=y || success_ifo=n
sed -i "s|${FileLoc}/||" "${outputpath}/${file_title_clean}.mediainfo.txt"
[[ $success_ifo == y ]] && echo -e "${green}DONE${normal}" || echo -e "${green}ERROR${normal}" ; }

# finished
echo -e "\n${bold}Done. Outputs are stored in ${yellow}\"${outputpath}\"${normal}\n"




#######################################################################################################################
#######################################################################################################################
#######################################################################################################################
#######################################################################################################################
#######################################################################################################################




function Deprecated() {
    DW=$VideoHeight
    DARX=` echo $DAR | sed "s/[0-9]\{1,\}://" `
    DARY=` echo $DAR | sed "s/:[0-9]\{1,\}//" `
  # DH0=` expr $VideoHeight / $DARX  `
  # DH=` expr $DH0 \* $DARY  `
    DH=` echo "$VideoHeight/$DARX*$DARY" | bc -l | awk '{print int($0)}' `

    echo -n "${yellow}${bold}The correct resolution should be ${underline}$fenbianlv${reset_underline},${normal} [${cyan}T${normal}]rue or [F]alse " ; read responce
    case $responce in
        [Tt] | [Tt][Ru][Uu][eE]     )  echo -e "The script will take 10 screenshots in $fenbianlv" ;;
        [Ff] | [Ff][Aa][Ll][Ss][Ee] )  resolution=input ;;
        ""   | *                    )  echo -e "The script will take 10 screenshots in $fenbianlv" ;;
    esac
# Transform numbers
# function  even_number () { [ ! $(($2%2)) == 0 ] && eval $1=$( expr $2 + 1 ) ; }


#######################################################################################################################
#######################################################################################################################
#######################################################################################################################
#######################################################################################################################
#######################################################################################################################

DAR=$( ffmpeg -i "$mediapath" 2>&1 | grep -Eo "DAR [0-9]+:[0-9]+" | sed "s/DAR //" | head -1 )
DARX=$( echo $DAR | sed "s/:[0-9]\{1,\}//" )
DARY=$( echo $DAR | sed "s/[0-9]\{1,\}://" )
SAR=$( ffmpeg -i "$mediapath" 2>&1 | grep -Eo "SAR [0-9]+:[0-9]+" | sed "s/SAR //" | head -1 )
SARX=$( echo $SAR | sed "s/:[0-9]\{1,\}//" )
SARY=$( echo $SAR | sed "s/[0-9]\{1,\}://" )

# 第一种，720×480 16:9，算出来 720×405，也就是重新计算 Y
# $VideoWidth/$DARY*$DARX=720÷16×9=405
DAR1_W=$VideoWidth
DAR1_H=$(awk "BEGIN{print $VideoWidth/$DARX*$DARY}" | awk '{print int($0)}')
[ ! $(($DAR1_H%2)) == 0 ] && DAR1_H=$( expr $DAR1_H + 1 )
DAR1_R="${DAR1_W}x${DAR1_H}"

# 第二种，720×480 16:9，算出来 853×480，也就是重新计算 X
# $VideoHeight/$DARX*$DARY=480÷9×16=853
DAR2_H=$VideoHeight
DAR2_W=$(awk "BEGIN{print $VideoHeight/$DARY*$DARX}" | awk '{print int($0)}')
[ ! $(($DAR2_W%2)) == 0 ] && DAR2_W=$( expr $DAR2_W + 1 )
DAR2_R="${DAR2_W}x${DAR2_H}"

# 第三种，看 SAR，720×480 32:27，算出来 853×480
# $VideoWidth/$SARX*$SARY=720÷27×32=853
SAR1_H=$VideoHeight
SAR1_W=$(awk "BEGIN{print $VideoWidth/$SARY*$SARX}" | awk '{print int($0)}')
[ ! $(($SAR1_W%2)) == 0 ] && SAR1_W=$( expr $SAR1_W + 1 )
SAR1_R="${SAR1_W}x${SAR1_H}"

# https://github.com/TnS-hun/PtpUploader/blob/master/src/PtpUploader/Tool/Ffmpeg.py#L42
# 有一种算法，是用 DAR 比视频分辨率的 AR 大时，重新算 X，反之 算 Y
# 蛋疼的是 shell 自带的那些不支持浮点数比较（除非用 bc），不过 expr 似乎是取整算法，比如
# expr 8 / 9  = 0
# expr 17 / 9 = 1
# 这样子的话可以根据 expr SAR 的数值来选择怎么操作
if [[ $( expr $SARX / $SARY ) == 0 ]] ; then
    resize=Y
    TrueRes="${DAR1_W}x${DAR1_H}"
else
    resize=X
    TrueRes="${DAR2_W}x${DAR2_H}"
fi

echo "
${cyan}${bold}DAR   Resolution       ${yellow}$TrueRes
${cyan}${bold}DAR-1 Resolution       ${yellow}$DAR1_R
${cyan}${bold}DAR-2 Resolution       ${yellow}$DAR2_R
${cyan}${bold}SAR   Resolution       ${yellow}$SAR1_R
"

echo -e "${bold}
${cyan}Sample  Aspect Ratio (ffmpeg)     ${yellow}$SAR
${cyan}Display Aspect Ratio (ffmpeg)     ${yellow}$DAR
${cyan}Display Aspect Ratio (mediainfo)  ${yellow}$DAR2
${cyan}Pixel   Aspect Ratio (mediainfo)  ${yellow}$PAR
${cyan}Video Resolution                  ${yellow}$VideoResolution  --->  $fenbianlv${normal}"

}

#######################################################################################################################
#######################################################################################################################
#######################################################################################################################
#######################################################################################################################
#######################################################################################################################




#######################################################################################################################
#######################################################################################################################
#######################################################################################################################

usage() {

s=/usr/local/bin/jietu;rm -f  && nano $s && chmod 755 $s
wget -q https://github.com/Aniverse/inexistence/raw/master/00.Installation/script/jietu -O /usr/local/bin/jietu && chmod +x /usr/local/bin/jietu

}
